"""
Auto-generated parser for ICICI bank statements
Generated by LangGraph Agent
"""
import pandas as pd
import pdfplumber
import re
import PyPDF2
from typing import Optional

import pandas as pd
import pdfplumber
import re

def parse(pdf_path: str) -> pd.DataFrame:
    """
    Parses an ICICI bank statement PDF and returns a Pandas DataFrame.

    Args:
        pdf_path: Path to the ICICI bank statement PDF.

    Returns:
        A Pandas DataFrame with columns ['Date', 'Description', 'Debit Amt', 'Credit Amt', 'Balance'].
        Returns an empty DataFrame if there's an error during parsing.
    """
    try:
        with pdfplumber.open(pdf_path) as pdf:
            all_transactions = []
            for page in pdf.pages:
                table = page.extract_table()
                #Skip header rows -  heuristic based on "Date" column presence
                start_index = 0
                for i, row in enumerate(table):
                    if row and "Date" in row[0]:
                        start_index = i + 1
                        break

                if start_index < len(table):
                    transactions = table[start_index:]
                    for row in transactions:
                        if len(row) >=5: #check if row contains all required data.
                            date_str, desc, debit, credit, balance = row[:5]

                            #Clean up date format if necessary.
                            date_str = date_str.strip()
                            match = re.match(r"(\d{2})-(\d{2})-(\d{4})", date_str)
                            if match:
                                date_str = match.group(0)
                            else:
                                #Handle potential date format issues more robustly.
                                print(f"Warning: Unrecognized date format: {date_str}. Skipping row.")
                                continue
                                

                            #Clean up amount strings and handle potential errors
                            try:
                                debit = float(debit.replace(",","")) if debit else ""
                                credit = float(credit.replace(",","")) if credit else ""
                                balance = float(balance.replace(",","")) if balance else ""
                            except ValueError as e:
                                print(f"Warning: Error converting amount to float: {e}. Skipping row.")
                                continue


                            all_transactions.append({
                                'Date': date_str,
                                'Description': desc.strip(),
                                'Debit Amt': debit,
                                'Credit Amt': credit,
                                'Balance': balance
                            })
                    

            df = pd.DataFrame(all_transactions)
            return df

    except FileNotFoundError:
        print(f"Error: File not found at {pdf_path}")
        return pd.DataFrame(columns=['Date', 'Description', 'Debit Amt', 'Credit Amt', 'Balance'])
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return pd.DataFrame(columns=['Date', 'Description', 'Debit Amt', 'Credit Amt', 'Balance'])



def _validate_output(df: pd.DataFrame) -> pd.DataFrame:
    """Ensure output matches expected schema"""
    expected_columns = ['Date', 'Description', 'Debit Amt', 'Credit Amt', 'Balance']
    
    if not isinstance(df, pd.DataFrame):
        raise ValueError("Parser must return a pandas DataFrame")
    
    # Add missing columns with empty strings
    for col in expected_columns:
        if col not in df.columns:
            df[col] = ''
    
    # Reorder to expected columns
    df = df[expected_columns]
    
    # Handle amount columns - preserve empty strings
    amount_cols = [col for col in expected_columns 
                  if any(word in col.lower() for word in ['amt', 'debit', 'credit', 'balance', 'amount'])]
    
    for col in amount_cols:
        df[col] = df[col].astype(str).replace(['nan', 'None', 'NaN'], '').fillna('')
    
    return df

# Wrap the generated parse function to ensure validation
_original_parse = parse

def parse(pdf_path: str) -> pd.DataFrame:
    """Main parse function with validation"""
    result = _original_parse(pdf_path)
    return _validate_output(result)
